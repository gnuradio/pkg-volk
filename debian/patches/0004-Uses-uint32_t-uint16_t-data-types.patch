From 485cd5d03635fdf2c7bf43f0775decf1cfbb60ec Mon Sep 17 00:00:00 2001
From: Tom Rondeau <tom@trondeau.com>
Date: Tue, 12 Apr 2016 10:07:38 -0400
Subject: [PATCH 4/6] Uses uint32_t/uint16_t data types.

Also, no need for an "if num_points > 0" since num_points is unsigned.
---
 kernels/volk/volk_32f_index_max_16u.h  | 182 +++++++++++++++++----------------
 kernels/volk/volk_32fc_index_max_16u.h |  30 +++---
 2 files changed, 108 insertions(+), 104 deletions(-)

diff --git a/kernels/volk/volk_32f_index_max_16u.h b/kernels/volk/volk_32f_index_max_16u.h
index 94ac317..42a78a1 100644
--- a/kernels/volk/volk_32f_index_max_16u.h
+++ b/kernels/volk/volk_32f_index_max_16u.h
@@ -25,11 +25,18 @@
  *
  * \b Overview
  *
- * Returns Argmax_i x[i]. Finds and returns the index which contains the maximum value in the given vector.
+ * Returns Argmax_i x[i]. Finds and returns the index which contains
+ * the maximum value in the given vector.
+ *
+ * Note that num_points is a uint32_t, but the return value is
+ * uint16_t. Providing a vector larger than the max of a uint16_t
+ * (65536) would miss anything outside of this boundary. The kernel
+ * will check the length of num_points and cap it to this max value,
+ * anyways.
  *
  * <b>Dispatcher Prototype</b>
  * \code
- * void volk_32f_index_max_16u(unsigned short* target, const float* src0, unsigned int num_points)
+ * void volk_32f_index_max_16u(uint16_t* target, const float* src0, uint32_t num_points)
  * \endcode
  *
  * \b Inputs
@@ -42,11 +49,11 @@
  * \b Example
  * \code
  *   int N = 10;
- *   unsigned int alignment = volk_get_alignment();
+ *   uint32_t alignment = volk_get_alignment();
  *   float* in = (float*)volk_malloc(sizeof(float)*N, alignment);
  *   uint16_t* out = (uint16_t*)volk_malloc(sizeof(uint16_t), alignment);
  *
- *   for(unsigned int ii = 0; ii < N; ++ii){
+ *   for(uint32_t ii = 0; ii < N; ++ii){
  *       float x = (float)ii;
  *       // a parabola with a maximum at x=4
  *       in[ii] = -(x-4) * (x-4) + 5;
@@ -73,58 +80,57 @@
 #include<smmintrin.h>
 
 static inline void
-volk_32f_index_max_16u_a_sse4_1(unsigned short* target, const float* src0, unsigned int num_points)
+volk_32f_index_max_16u_a_sse4_1(uint16_t* target, const float* src0,
+                                uint32_t num_points)
 {
-  if(num_points > 0){
-    unsigned int number = 0;
-    const unsigned int quarterPoints = num_points / 4;
+  uint32_t number = 0;
+  const uint32_t quarterPoints = num_points / 4;
 
-    float* inputPtr = (float*)src0;
+  float* inputPtr = (float*)src0;
 
-    __m128 indexIncrementValues = _mm_set1_ps(4);
-    __m128 currentIndexes = _mm_set_ps(-1,-2,-3,-4);
+  __m128 indexIncrementValues = _mm_set1_ps(4);
+  __m128 currentIndexes = _mm_set_ps(-1,-2,-3,-4);
 
-    float max = src0[0];
-    float index = 0;
-    __m128 maxValues = _mm_set1_ps(max);
-    __m128 maxValuesIndex = _mm_setzero_ps();
-    __m128 compareResults;
-    __m128 currentValues;
+  float max = src0[0];
+  float index = 0;
+  __m128 maxValues = _mm_set1_ps(max);
+  __m128 maxValuesIndex = _mm_setzero_ps();
+  __m128 compareResults;
+  __m128 currentValues;
 
-    __VOLK_ATTR_ALIGNED(16) float maxValuesBuffer[4];
-    __VOLK_ATTR_ALIGNED(16) float maxIndexesBuffer[4];
+  __VOLK_ATTR_ALIGNED(16) float maxValuesBuffer[4];
+  __VOLK_ATTR_ALIGNED(16) float maxIndexesBuffer[4];
 
-    for(;number < quarterPoints; number++){
+  for(;number < quarterPoints; number++){
 
-      currentValues  = _mm_load_ps(inputPtr); inputPtr += 4;
-      currentIndexes = _mm_add_ps(currentIndexes, indexIncrementValues);
+    currentValues  = _mm_load_ps(inputPtr); inputPtr += 4;
+    currentIndexes = _mm_add_ps(currentIndexes, indexIncrementValues);
 
-      compareResults = _mm_cmpgt_ps(maxValues, currentValues);
+    compareResults = _mm_cmpgt_ps(maxValues, currentValues);
 
-      maxValuesIndex = _mm_blendv_ps(currentIndexes, maxValuesIndex, compareResults);
-      maxValues      = _mm_blendv_ps(currentValues, maxValues, compareResults);
-    }
+    maxValuesIndex = _mm_blendv_ps(currentIndexes, maxValuesIndex, compareResults);
+    maxValues      = _mm_blendv_ps(currentValues, maxValues, compareResults);
+  }
 
-    // Calculate the largest value from the remaining 4 points
-    _mm_store_ps(maxValuesBuffer, maxValues);
-    _mm_store_ps(maxIndexesBuffer, maxValuesIndex);
+  // Calculate the largest value from the remaining 4 points
+  _mm_store_ps(maxValuesBuffer, maxValues);
+  _mm_store_ps(maxIndexesBuffer, maxValuesIndex);
 
-    for(number = 0; number < 4; number++){
-      if(maxValuesBuffer[number] > max){
-	index = maxIndexesBuffer[number];
-	max = maxValuesBuffer[number];
-      }
+  for(number = 0; number < 4; number++){
+    if(maxValuesBuffer[number] > max){
+      index = maxIndexesBuffer[number];
+      max = maxValuesBuffer[number];
     }
+  }
 
-    number = quarterPoints * 4;
-    for(;number < num_points; number++){
-      if(src0[number] > max){
-	index = number;
-	max = src0[number];
-      }
+  number = quarterPoints * 4;
+  for(;number < num_points; number++){
+    if(src0[number] > max){
+      index = number;
+      max = src0[number];
     }
-    target[0] = (unsigned short)index;
   }
+  target[0] = (uint16_t)index;
 }
 
 #endif /*LV_HAVE_SSE4_1*/
@@ -135,59 +141,58 @@ volk_32f_index_max_16u_a_sse4_1(unsigned short* target, const float* src0, unsig
 #include<xmmintrin.h>
 
 static inline void
-volk_32f_index_max_16u_a_sse(unsigned short* target, const float* src0, unsigned int num_points)
+volk_32f_index_max_16u_a_sse(uint16_t* target, const float* src0,
+                             uint32_t num_points)
 {
-  if(num_points > 0){
-    unsigned int number = 0;
-    const unsigned int quarterPoints = num_points / 4;
+  uint32_t number = 0;
+  const uint32_t quarterPoints = num_points / 4;
 
-    float* inputPtr = (float*)src0;
+  float* inputPtr = (float*)src0;
 
-    __m128 indexIncrementValues = _mm_set1_ps(4);
-    __m128 currentIndexes = _mm_set_ps(-1,-2,-3,-4);
+  __m128 indexIncrementValues = _mm_set1_ps(4);
+  __m128 currentIndexes = _mm_set_ps(-1,-2,-3,-4);
 
-    float max = src0[0];
-    float index = 0;
-    __m128 maxValues = _mm_set1_ps(max);
-    __m128 maxValuesIndex = _mm_setzero_ps();
-    __m128 compareResults;
-    __m128 currentValues;
+  float max = src0[0];
+  float index = 0;
+  __m128 maxValues = _mm_set1_ps(max);
+  __m128 maxValuesIndex = _mm_setzero_ps();
+  __m128 compareResults;
+  __m128 currentValues;
 
-    __VOLK_ATTR_ALIGNED(16) float maxValuesBuffer[4];
-    __VOLK_ATTR_ALIGNED(16) float maxIndexesBuffer[4];
+  __VOLK_ATTR_ALIGNED(16) float maxValuesBuffer[4];
+  __VOLK_ATTR_ALIGNED(16) float maxIndexesBuffer[4];
 
-    for(;number < quarterPoints; number++){
+  for(;number < quarterPoints; number++){
 
-      currentValues  = _mm_load_ps(inputPtr); inputPtr += 4;
-      currentIndexes = _mm_add_ps(currentIndexes, indexIncrementValues);
+    currentValues  = _mm_load_ps(inputPtr); inputPtr += 4;
+    currentIndexes = _mm_add_ps(currentIndexes, indexIncrementValues);
 
-      compareResults = _mm_cmpgt_ps(maxValues, currentValues);
+    compareResults = _mm_cmpgt_ps(maxValues, currentValues);
 
-      maxValuesIndex = _mm_or_ps(_mm_and_ps(compareResults, maxValuesIndex) , _mm_andnot_ps(compareResults, currentIndexes));
+    maxValuesIndex = _mm_or_ps(_mm_and_ps(compareResults, maxValuesIndex) , _mm_andnot_ps(compareResults, currentIndexes));
 
-      maxValues      = _mm_or_ps(_mm_and_ps(compareResults, maxValues) , _mm_andnot_ps(compareResults, currentValues));
-    }
+    maxValues      = _mm_or_ps(_mm_and_ps(compareResults, maxValues) , _mm_andnot_ps(compareResults, currentValues));
+  }
 
-    // Calculate the largest value from the remaining 4 points
-    _mm_store_ps(maxValuesBuffer, maxValues);
-    _mm_store_ps(maxIndexesBuffer, maxValuesIndex);
+  // Calculate the largest value from the remaining 4 points
+  _mm_store_ps(maxValuesBuffer, maxValues);
+  _mm_store_ps(maxIndexesBuffer, maxValuesIndex);
 
-    for(number = 0; number < 4; number++){
-      if(maxValuesBuffer[number] > max){
-	index = maxIndexesBuffer[number];
-	max = maxValuesBuffer[number];
-      }
+  for(number = 0; number < 4; number++){
+    if(maxValuesBuffer[number] > max){
+      index = maxIndexesBuffer[number];
+      max = maxValuesBuffer[number];
     }
+  }
 
-    number = quarterPoints * 4;
-    for(;number < num_points; number++){
-      if(src0[number] > max){
-	index = number;
-	max = src0[number];
-      }
+  number = quarterPoints * 4;
+  for(;number < num_points; number++){
+    if(src0[number] > max){
+      index = number;
+      max = src0[number];
     }
-    target[0] = (unsigned short)index;
   }
+  target[0] = (uint16_t)index;
 }
 
 #endif /*LV_HAVE_SSE*/
@@ -196,22 +201,21 @@ volk_32f_index_max_16u_a_sse(unsigned short* target, const float* src0, unsigned
 #ifdef LV_HAVE_GENERIC
 
 static inline void
-volk_32f_index_max_16u_generic(unsigned short* target, const float* src0, unsigned int num_points)
+volk_32f_index_max_16u_generic(uint16_t* target, const float* src0,
+                               uint32_t num_points)
 {
-  if(num_points > 0){
-    float max = src0[0];
-    unsigned short index = 0;
+  float max = src0[0];
+  uint16_t index = 0;
 
-    unsigned int i = 1;
+  uint32_t i = 1;
 
-    for(; i < num_points; ++i) {
-      if(src0[i] > max){
-        index = i;
-        max = src0[i];
-      }
+  for(; i < num_points; ++i) {
+    if(src0[i] > max) {
+      index = i;
+      max = src0[i];
     }
-    target[0] = index;
   }
+  target[0] = index;
 }
 
 #endif /*LV_HAVE_GENERIC*/
diff --git a/kernels/volk/volk_32fc_index_max_16u.h b/kernels/volk/volk_32fc_index_max_16u.h
index c5944fd..4843ce6 100644
--- a/kernels/volk/volk_32fc_index_max_16u.h
+++ b/kernels/volk/volk_32fc_index_max_16u.h
@@ -30,7 +30,7 @@
  *
  * <b>Dispatcher Prototype</b>
  * \code
- * void volk_32fc_index_max_16u(unsigned short* target, lv_32fc_t* src0, unsigned int num_points)
+ * void volk_32fc_index_max_16u(uint16_t* target, lv_32fc_t* src0, uint32_t num_points)
  * \endcode
  *
  * \b Inputs
@@ -45,11 +45,11 @@
  * the unit circle.
  * \code
  *   int N = 10;
- *   unsigned int alignment = volk_get_alignment();
+ *   uint32_t alignment = volk_get_alignment();
  *   lv_32fc_t* in  = (lv_32fc_t*)volk_malloc(sizeof(lv_32fc_t)*N, alignment);
  *   uint16_t* max = (uint16_t*)volk_malloc(sizeof(uint16_t), alignment);
  *
- *   for(unsigned int ii = 0; ii < N/2; ++ii){
+ *   for(uint32_t ii = 0; ii < N/2; ++ii){
  *       float real = 2.f * ((float)ii / (float)N) - 1.f;
  *       float imag = std::sqrt(1.f - real * real);
  *       in[ii] = lv_cmake(real, imag);
@@ -80,10 +80,10 @@
 #include<pmmintrin.h>
 
 static inline void
-volk_32fc_index_max_16u_a_sse3(unsigned short* target, lv_32fc_t* src0,
-                               unsigned int num_points)
+volk_32fc_index_max_16u_a_sse3(uint16_t* target, lv_32fc_t* src0,
+                               uint32_t num_points)
 {
-  const unsigned int num_bytes = num_points*8;
+  const uint32_t num_bytes = num_points*8;
 
   union bit128 holderf;
   union bit128 holderi;
@@ -206,11 +206,11 @@ volk_32fc_index_max_16u_a_sse3(unsigned short* target, lv_32fc_t* src0,
   /*
   float placeholder = 0.0;
   uint32_t temp0, temp1;
-  unsigned int g0 = (((float*)&xmm3)[0] > ((float*)&xmm3)[1]);
-  unsigned int l0 = g0 ^ 1;
+  uint32_t g0 = (((float*)&xmm3)[0] > ((float*)&xmm3)[1]);
+  uint32_t l0 = g0 ^ 1;
 
-  unsigned int g1 = (((float*)&xmm3)[1] > ((float*)&xmm3)[2]);
-  unsigned int l1 = g1 ^ 1;
+  uint32_t g1 = (((float*)&xmm3)[1] > ((float*)&xmm3)[2]);
+  uint32_t l1 = g1 ^ 1;
 
   temp0 = g0 * ((uint32_t*)&xmm9)[0] + l0 * ((uint32_t*)&xmm9)[1];
   temp1 = g0 * ((uint32_t*)&xmm9)[2] + l0 * ((uint32_t*)&xmm9)[3];
@@ -227,16 +227,16 @@ volk_32fc_index_max_16u_a_sse3(unsigned short* target, lv_32fc_t* src0,
 
 #ifdef LV_HAVE_GENERIC
 static inline void
- volk_32fc_index_max_16u_generic(unsigned short* target, lv_32fc_t* src0,
-                                 unsigned int num_points)
+ volk_32fc_index_max_16u_generic(uint16_t* target, lv_32fc_t* src0,
+                                 uint32_t num_points)
 {
-  const unsigned int num_bytes = num_points*8;
+  const uint32_t num_bytes = num_points*8;
 
   float sq_dist = 0.0;
   float max = 0.0;
-  unsigned short index = 0;
+  uint16_t index = 0;
 
-  unsigned int i = 0;
+  uint32_t i = 0;
 
   for(; i < num_bytes >> 3; ++i) {
     sq_dist = lv_creal(src0[i]) * lv_creal(src0[i]) + lv_cimag(src0[i]) * lv_cimag(src0[i]);
-- 
2.1.4

