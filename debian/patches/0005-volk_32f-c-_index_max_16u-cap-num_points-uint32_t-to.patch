From 04a1fd7a2bf8c90add97961c6ab2724ee2d9e322 Mon Sep 17 00:00:00 2001
From: Tom Rondeau <tom@trondeau.com>
Date: Tue, 12 Apr 2016 12:30:46 -0400
Subject: [PATCH 5/6] volk_32f{c}_index_max_16u: cap num_points (uint32_t) to
 max short.

---
 kernels/volk/volk_32f_index_max_16u.h  | 11 +++++++++--
 kernels/volk/volk_32fc_index_max_16u.h | 23 ++++++++++++++++++-----
 2 files changed, 27 insertions(+), 7 deletions(-)

diff --git a/kernels/volk/volk_32f_index_max_16u.h b/kernels/volk/volk_32f_index_max_16u.h
index 42a78a1..91d2976 100644
--- a/kernels/volk/volk_32f_index_max_16u.h
+++ b/kernels/volk/volk_32f_index_max_16u.h
@@ -74,15 +74,18 @@
 #include <volk/volk_common.h>
 #include <volk/volk_common.h>
 #include <inttypes.h>
+#include <limits.h>
 #include <stdio.h>
 
 #ifdef LV_HAVE_SSE4_1
-#include<smmintrin.h>
+#include <smmintrin.h>
 
 static inline void
 volk_32f_index_max_16u_a_sse4_1(uint16_t* target, const float* src0,
                                 uint32_t num_points)
 {
+  num_points = (num_points > USHRT_MAX) ? USHRT_MAX : num_points;
+
   uint32_t number = 0;
   const uint32_t quarterPoints = num_points / 4;
 
@@ -138,12 +141,14 @@ volk_32f_index_max_16u_a_sse4_1(uint16_t* target, const float* src0,
 
 #ifdef LV_HAVE_SSE
 
-#include<xmmintrin.h>
+#include <xmmintrin.h>
 
 static inline void
 volk_32f_index_max_16u_a_sse(uint16_t* target, const float* src0,
                              uint32_t num_points)
 {
+  num_points = (num_points > USHRT_MAX) ? USHRT_MAX : num_points;
+
   uint32_t number = 0;
   const uint32_t quarterPoints = num_points / 4;
 
@@ -204,6 +209,8 @@ static inline void
 volk_32f_index_max_16u_generic(uint16_t* target, const float* src0,
                                uint32_t num_points)
 {
+  num_points = (num_points > USHRT_MAX) ? USHRT_MAX : num_points;
+
   float max = src0[0];
   uint16_t index = 0;
 
diff --git a/kernels/volk/volk_32fc_index_max_16u.h b/kernels/volk/volk_32fc_index_max_16u.h
index 4843ce6..c13196a 100644
--- a/kernels/volk/volk_32fc_index_max_16u.h
+++ b/kernels/volk/volk_32fc_index_max_16u.h
@@ -28,6 +28,12 @@
  * Returns Argmax_i mag(x[i]). Finds and returns the index which contains the
  * maximum magnitude for complex points in the given vector.
  *
+ * Note that num_points is a uint32_t, but the return value is
+ * uint16_t. Providing a vector larger than the max of a uint16_t
+ * (65536) would miss anything outside of this boundary. The kernel
+ * will check the length of num_points and cap it to this max value,
+ * anyways.
+ *
  * <b>Dispatcher Prototype</b>
  * \code
  * void volk_32fc_index_max_16u(uint16_t* target, lv_32fc_t* src0, uint32_t num_points)
@@ -71,18 +77,23 @@
 #define INCLUDED_volk_32fc_index_max_16u_a_H
 
 #include <volk/volk_common.h>
-#include<inttypes.h>
-#include<stdio.h>
-#include<volk/volk_complex.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <limits.h>
+#include <volk/volk_complex.h>
 
 #ifdef LV_HAVE_SSE3
-#include<xmmintrin.h>
-#include<pmmintrin.h>
+#include <xmmintrin.h>
+#include <pmmintrin.h>
 
 static inline void
 volk_32fc_index_max_16u_a_sse3(uint16_t* target, lv_32fc_t* src0,
                                uint32_t num_points)
 {
+  num_points = (num_points > USHRT_MAX) ? USHRT_MAX : num_points;
+  // Branchless version, if we think it'll make a difference
+  //num_points = USHRT_MAX ^ ((num_points ^ USHRT_MAX) & -(num_points < USHRT_MAX));
+
   const uint32_t num_bytes = num_points*8;
 
   union bit128 holderf;
@@ -230,6 +241,8 @@ static inline void
  volk_32fc_index_max_16u_generic(uint16_t* target, lv_32fc_t* src0,
                                  uint32_t num_points)
 {
+  num_points = (num_points > USHRT_MAX) ? USHRT_MAX : num_points;
+
   const uint32_t num_bytes = num_points*8;
 
   float sq_dist = 0.0;
-- 
2.1.4

